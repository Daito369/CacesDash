<script>
    /**
     * @fileoverview dashboard.html - ダッシュボード機能
     * アクティブなケースの一覧表示、ケースカードの生成、
     * ケース編集モーダルの表示と更新処理を担当します。
     *
     * @requires script.html (for common functions like showSnackbar, createMdc*, initDatePicker, etc.)
     * @requires dataAccess.gs (via google.script.run for getSheetData, searchCaseById, updateCaseData)
     * @requires settings.gs (indirectly for spreadsheetId check)
     */

    /**
     * ダッシュボードタブがアクティブになったときに呼び出される初期化関数。
     * スプレッドシートIDが設定されているか確認し、設定されていればケースデータを読み込みます。
     * 更新ボタンのイベントリスナーも設定します。
     * (script.html の triggerTabLoadAction から呼び出される想定)
     */
    function initializeDashboard() {
        const container = document.getElementById('activeCasesList');
        if (!container) {
            console.error("Dashboard container #activeCasesList not found.");
            return;
        }

        // スプレッドシートIDが設定されているかグローバル変数で確認
        if (!currentSettings || !currentSettings.spreadsheetId) {
            console.warn("Spreadsheet ID not set. Dashboard cannot be loaded.");
            container.innerHTML = `
      <div class="not-configured-message">
        <i class="material-icons-outlined">settings</i>
        <p>スプレッドシートIDが設定されていません。「設定」タブで設定してください。</p>
      </div>`;
            // 設定が必要なエラー表示をクリア (他のタブで表示されている可能性)
            clearContentErrors(['sheetError', 'dataError']);
            return;
        } else {
            // IDが設定されていれば設定要求エラーはクリア
            clearContentErrors('configNeeded');
        }

        // 更新ボタンにイベントリスナーを設定 (一度だけ)
        const refreshButton = document.getElementById('refreshDashboard');
        if (refreshButton && !refreshButton.dataset.listenerAttached) {
            refreshButton.addEventListener('click', loadCasesData);
            refreshButton.dataset.listenerAttached = 'true'; // リスナー再設定防止フラグ
            console.log("Refresh button listener attached.");
        }

        // ケースデータを読み込み開始
        loadCasesData();
    }

    /**
     * バックエンド (dataAccess.gs の getSheetData) を呼び出して、
     * 現在のユーザーが担当するケースデータを非同期で取得します。
     * 取得中はローディングインジケーターを表示します。
     */
    function loadCasesData() {
        const container = document.getElementById('activeCasesList');
        if (!container) return;

        console.log("Loading cases data...");
        // ローディング表示
        container.innerHTML = `
    <div class="loading-container">
      <div class="mdc-linear-progress mdc-linear-progress--indeterminate" role="progressbar" aria-label="Loading cases" aria-valuemin="0" aria-valuemax="1">
        <div class="mdc-linear-progress__buffer"><div class="mdc-linear-progress__buffer-dots"></div><div class="mdc-linear-progress__buffer-bar"></div></div>
        <div class="mdc-linear-progress__bar mdc-linear-progress__primary-bar"><span class="mdc-linear-progress__bar-inner"></span></div>
        <div class="mdc-linear-progress__bar mdc-linear-progress__secondary-bar"><span class="mdc-linear-progress__bar-inner"></span></div>
      </div>
      <p>担当ケースを読み込み中...</p>
    </div>`;

        // プログレスバーの初期化
        const progressBar = container.querySelector('.mdc-linear-progress');
        if (progressBar) {
            try {
                new mdc.linearProgress.MDCLinearProgress(progressBar);
            } catch (e) { console.warn("Failed to init progress bar for loading", e); }
        }

        // google.script.run でバックエンド関数を呼び出し
        google.script.run
            .withSuccessHandler(result => {
                if (result.success) {
                    console.log(`Successfully loaded ${result.data?.length || 0} cases.`);
                    displayCasesData(result.data || []); // 取得成功、データを表示関数へ
                } else {
                    // バックエンドがエラーを返した場合
                    console.error("Failed to load cases data:", result.message);
                    container.innerHTML = `
          <div class="error-message">
            <i class="material-icons-outlined">error_outline</i>
            <p>${result.message || 'データの取得に失敗しました。'}</p>
            <button class="mdc-button mdc-button--outlined retry-load-btn" style="margin-top: 16px;">
              <span class="mdc-button__ripple"></span>
              <span class="mdc-button__label">再試行</span>
            </button>
          </div>`;
                    setupRetryButton(container); // 再試行ボタン設定
                    showSnackbar(result.message || 'データの取得に失敗しました。', 'error');
                }
            })
            .withFailureHandler(error => {
                // API呼び出し自体が失敗した場合 (ネットワークエラーなど)
                console.error("Error calling getSheetData:", error);
                const errorMessage = `データ取得API呼び出しエラー: ${error.message}`;
                container.innerHTML = `
        <div class="error-message">
          <i class="material-icons-outlined">cloud_off</i>
          <p>${errorMessage}</p>
          <button class="mdc-button mdc-button--outlined retry-load-btn" style="margin-top: 16px;">
            <span class="mdc-button__ripple"></span>
            <span class="mdc-button__label">再試行</span>
          </button>
        </div>`;
                setupRetryButton(container); // 再試行ボタン設定
                showSnackbar(errorMessage, 'error');
            })
            .getSheetData(); // dataAccess.gs の関数
    }

    /**
     * エラーメッセージ内の再試行ボタンにイベントリスナーとリップル効果を設定します。
     * @param {HTMLElement} container - ボタンが含まれるコンテナ要素。
     */
    function setupRetryButton(container) {
        const retryBtn = container.querySelector('.retry-load-btn');
        if (retryBtn) {
            try {
                new mdc.ripple.MDCRipple(retryBtn);
            } catch (e) { console.warn("Failed to init ripple for retry button", e); }
            retryBtn.addEventListener('click', loadCasesData);
        }
    }

    /**
     * 取得したケースデータ配列を処理し、ダッシュボードにケースカードを表示します。
     * "Assigned" ステータスのケースのみを表示対象とします。
     * @param {Array<Object<string, string>>} casesData - GASから取得したケースデータの配列。
     */
    function displayCasesData(casesData) {
        const container = document.getElementById('activeCasesList');
        if (!container) return;

        // "Assigned" ステータスのケースのみフィルタリング
        const assignedCases = casesData.filter(caseData => caseData['Case Status'] === 'Assigned');
        console.log(`Displaying ${assignedCases.length} assigned cases.`);

        if (assignedCases.length === 0) {
            // 表示するケースがない場合のメッセージ
            container.innerHTML = `
      <div class="empty-message">
        <i class="material-icons-outlined">task_alt</i>
        <p>現在、対応中のケース (Assigned) はありません。</p>
      </div>`;
            return;
        }

        // フラグを使ってイベントリスナーの重複設定を防止
        if (container.dataset.listenersAttached === 'true') {
            // 既存のカードをクリアしてから再描画
            container.innerHTML = '';
        } else {
            container.dataset.listenersAttached = 'true';
        }

        // ドキュメントフラグメントを使って一括DOM挿入
        const fragment = document.createDocumentFragment();

        assignedCases.forEach((caseData, index) => {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = createCaseCardHtml(caseData, index);
            const card = tempDiv.firstElementChild;
            if (card) {
                fragment.appendChild(card);
            }
        });

        container.appendChild(fragment);

        // MDCリップル効果の初期化
        container.querySelectorAll('.mdc-card').forEach(card => {
            card.querySelectorAll('.mdc-button, .mdc-icon-button').forEach(btn => {
                if (!btn._mdcRipple) {
                    try { btn._mdcRipple = new mdc.ripple.MDCRipple(btn); } catch (e) { console.warn("Failed to init ripple on card button", e); }
                }
            });
        });

        // イベントリスナーの設定（重複防止のため既存リスナーを削除してから設定）
        setupCaseCardEventListeners(container);

        // タイマー表示を初期化/更新 (script.html で定義)
        if (typeof updateTimers === 'function') {
            updateTimers();
        } else {
            console.warn("updateTimers function not found.");
        }

        // 管理者向けの残り8時間以下ケース一覧を読み込み表示 (未実装のためコメントアウト)
        // loadAdminUrgentCases();
    }

    /**
     * ケースデータオブジェクトから1つのケースカードのHTML文字列を生成します。
     * @param {Object<string, string>} caseData - ケースデータオブジェクト。スプレッドシートのヘッダー名がキー。
     * @param {number} index - ループのインデックス (主に `key` 属性用)。
     * @param {boolean} [isSearchResult=false] - 検索結果表示モードかどうか。trueの場合、非アクティブケースに「アクティブ化」ボタンを表示。
     * @returns {string} 生成されたケースカードのHTML文字列。データが無効な場合は空文字列。
     */
    function createCaseCardHtml(caseData, index, isSearchResult = false) {
        // caseData と Case ID の存在チェック
        if (!caseData || !caseData['Case ID']) {
            console.warn("Invalid case data provided to createCaseCardHtml:", caseData);
            return '';
        }

        const caseId = caseData['Case ID'];
        const status = caseData['Case Status'] || '不明';
        const statusClass = getStatusClass(status); // このファイル内で定義
        const date = formatDate(caseData['Date']); // script.html で定義
        const time = formatTime(caseData['Time']); // script.html で定義

        // --- タイマー関連データ ---
        // Response SLA デッドライン (バックエンドから ISO 8601 形式などで渡される想定)
        const slaDeadline = caseData['slaDeadline'] || ''; // 例: '2025-04-17T10:00:00Z'

        // P95 デッドライン (バックエンドから ISO 8601 形式などで渡される想定)
        const p95Deadline = caseData['p95Deadline'] || ''; // 例: '2025-04-19T18:59:00Z'

        // T&S Consulted フラグ (P95計算用、バックエンドから渡される想定)
        // スプレッドシートに列がない場合、別途管理方法が必要
        const tsConsulted = caseData['T&S Consulted'] === 'Yes'; // 例: 'Yes' or ''

        // --- カードスタイル ---
        let accentColor = 'var(--md-sys-color-primary)'; // デフォルト (Assigned)
        let cardClass = '';
        if (status === 'Solution Offered') {
            accentColor = 'var(--md-sys-color-warning, orange)'; // フォールバック色
            cardClass = 'status-solution-offered-card';
        } else if (status === 'Finished') {
            accentColor = 'var(--md-sys-color-tertiary, green)'; // フォールバック色
            cardClass = 'status-finished-card';
        }

        // --- HTML生成開始 ---
        let html = `
    <div class="mdc-card mdc-card--outlined case-card ${cardClass}" data-case-id="${caseId}" key="case-${index}" style="--card-accent-color: ${accentColor};">
      <div class="mdc-card__content">
        <div class="case-card-header">
          <div class="case-id" title="${caseId}">
            <i class="material-icons-outlined" aria-hidden="true">assignment</i>
            <a href="https://cases.connect.corp.google.com/#/case/${caseId}" target="_blank" rel="noopener noreferrer" title="Open in Cases Connect">${caseId}</a>
          </div>
          <div class="case-status ${statusClass}" title="ステータス: ${status}">${status}</div>
        </div>

        <div class="case-info">
          <div class="info-item">
            <div class="info-label">開始日時</div>
            <div class="info-value">${date} ${time}</div>
          </div>
          <div class="info-item">
            <div class="info-label">セグメント</div>
            <div class="info-value">${caseData['Segment'] || '-'}</div>
          </div>
          <div class="info-item">
            <div class="info-label">製品カテゴリ</div>
            <div class="info-value">${caseData['Product Category'] || '-'}</div>
          </div>
          <div class="info-item">
            <div class="info-label">担当者 (1st)</div>
            <div class="info-value">${caseData['1st Assignee'] || '-'}</div>
          </div>
        </div>

        <div class="case-info">
          <div class="info-item">
            <div class="info-label">問題カテゴリ</div>
            <div class="info-value">${caseData['Issue Category'] || '-'}</div>
          </div>
          <div class="info-item">
            <div class="info-label">最終担当者</div>
            <div class="info-value">${caseData['Final Assignee'] || '-'}</div>
          </div>
        </div>`;

        // --- オプション項目 (チップ表示) ---
        const optionalItems = [];
        if (caseData['Bug'] && caseData['Bug'] !== 'FALSE' && caseData['Bug'] !== '0')
            optionalItems.push({ text: 'Bug', class: 'chip-bug' });
        if (caseData['Need Info'] && caseData['Need Info'] !== 'FALSE' && caseData['Need Info'] !== '0')
            optionalItems.push({ text: 'Need Info', class: 'chip-need-info' });
        if (caseData['AM Transfer'])
            optionalItems.push({ text: `AM: ${caseData['AM Transfer']}`, class: 'chip-am-transfer' });
        if (caseData['non NCC'])
            optionalItems.push({ text: `non NCC: ${caseData['non NCC']}`, class: 'chip-non-ncc' });
        // T&S Consulted フラグも表示する場合
        if (tsConsulted)
            optionalItems.push({ text: 'T&S Consulted', class: 'chip-ts' });
        // Sentiment Score も表示する場合 (オプション)
        if (caseData['Sentiment Score'])
            optionalItems.push({ text: `Sentiment: ${caseData['Sentiment Score']}`, class: 'chip-sentiment' });


        if (optionalItems.length > 0) {
            html += `
        <div class="status-collection">
          ${optionalItems.map(item => `<div class="status-chip ${item.class || ''}">${item.text}</div>`).join('')}
        </div>`;
        }

        // --- タイマー表示 (Assigned ステータスの場合のみ) ---
        if (status === 'Assigned') {
            // P95タイマーを優先表示するための data 属性を追加
            html += `
        <div class="case-timer"
             data-date="${date}"
             data-time="${time}"
             data-status="${status}"
             ${slaDeadline ? `data-deadline="${slaDeadline}"` : ''}
             ${p95Deadline ? `data-p95-deadline="${p95Deadline}"` : ''}
             ${tsConsulted ? `data-ts-consulted="true"` : ''}>
          <i class="material-icons-outlined timer-icon" aria-hidden="true">timer</i>
          <span class="timer-label">読み込み中...</span>
          <span class="timer-value">--:--:--</span>
        </div>`;
        }

        // --- 最終アクション日時 (Assigned 以外の場合) ---
        if (status !== 'Assigned') {
            let lastActionDate = '';
            let lastActionTime = '';
            let actionLabel = '最終アクション日時';

            // クローズ日時を優先して表示
            if (caseData['Reopen Close Date']) {
                lastActionDate = formatDate(caseData['Reopen Close Date']);
                lastActionTime = formatTime(caseData['Reopen Close Time']) || '';
                actionLabel = '再クローズ日時';
            } else if (caseData['1st Close Date']) {
                lastActionDate = formatDate(caseData['1st Close Date']);
                lastActionTime = formatTime(caseData['1st Close Time']) || '';
                actionLabel = '初回クローズ日時';
            }

            if (lastActionDate) {
                html += `
          <div class="case-info last-action-info">
            <div class="info-item">
              <div class="info-label">${actionLabel}</div>
              <div class="info-value">${lastActionDate} ${lastActionTime}</div>
            </div>
          </div>`;
            }
        }

        // --- カードアクション ---
        html += `
      </div>
      <div class="mdc-card__actions case-actions">`;

        // 検索結果表示で、かつ Assigned でない場合に「アクティブ化」ボタンを表示
        if (isSearchResult && status !== 'Assigned') {
            html += `
          <button class="mdc-button mdc-button--outlined add-to-dashboard-btn" data-case-id="${caseId}" title="このケースを再度アクティブにする (ステータスを Assigned に変更)">
            <span class="mdc-button__ripple"></span>
            <i class="material-icons-outlined mdc-button__icon" aria-hidden="true">add_task</i>
            <span class="mdc-button__label">アクティブ化</span>
          </button>`;
        }

        // 常に編集ボタンを表示
        html += `
        <button class="mdc-button mdc-button--raised edit-case-btn" data-case-id="${caseId}" title="ケースの詳細を表示・編集する">
          <span class="mdc-button__ripple"></span>
          <i class="material-icons-outlined mdc-button__icon" aria-hidden="true">edit</i>
          <span class="mdc-button__label">編集</span>
        </button>
      </div>
    </div>`; // .mdc-card の閉じタグ

        return html;
    }

    /**
     * 指定されたコンテナ内のケースカード要素に含まれるボタン
     * (編集ボタン、アクティブ化ボタン) にイベントリスナーを設定します。
     * @param {HTMLElement} container - イベントリスナーを設定する範囲の親要素 (例: #activeCasesList, #searchResultContainer)。
     */
    function setupCaseCardEventListeners(container) {
        if (!container) return;

        // 編集ボタン (Event Delegation を使う方が効率的かもしれないが、ここでは個別設定)
        container.querySelectorAll('.edit-case-btn').forEach(button => {
            // 既存のリスナーがあれば削除 (重複設定防止)
            button.removeEventListener('click', handleEditButtonClick);
            button.addEventListener('click', handleEditButtonClick);
        });

        // ダッシュボードに追加 (アクティブ化) ボタン
        container.querySelectorAll('.add-to-dashboard-btn').forEach(button => {
            button.removeEventListener('click', handleAddToDashboardClick);
            button.addEventListener('click', handleAddToDashboardClick);
        });
        console.log("Event listeners set up for case card buttons.");
    }

    /**
     * 編集ボタンがクリックされたときの処理。
     * 対応するケースIDを取得し、編集モーダルを開きます。
     * @param {MouseEvent} event - クリックイベントオブジェクト。
     */
    function handleEditButtonClick(event) {
        console.log("handleEditButtonClick called"); // デバッグログ追加
        const button = event.currentTarget;
        const caseId = button.dataset.caseId;
        console.log("Case ID from button:", caseId); // デバッグログ追加
        if (caseId) {
            console.log(`Edit button clicked for case: ${caseId}`);
            openCaseEditModal(caseId); // このファイル内で定義
        } else {
            console.error("Case ID not found on edit button dataset.");
            showSnackbar("ケースIDが見つからず、編集画面を開けません。", "error");
        }
    }

    /**
     * アクティブ化ボタンがクリックされたときの処理。
     * 対応するケースIDのステータスをバックエンドで 'Assigned' に更新します。
     * @param {MouseEvent} event - クリックイベントオブジェクト。
     */
    function handleAddToDashboardClick(event) {
        const button = event.currentTarget;
        const caseId = button.dataset.caseId;
        const card = button.closest('.case-card'); // ボタンが含まれるカード要素

        if (!caseId || !card) {
            console.error("Could not find caseId or card element for add-to-dashboard action.");
            showSnackbar("ケース情報の取得に失敗しました。", "error");
            return;
        }

        console.log(`Activating case: ${caseId}`);
        // ボタンを一時的に無効化し、ローディング表示
        button.disabled = true;
        const originalLabel = button.querySelector('.mdc-button__label').textContent;
        const originalIcon = button.querySelector('.material-icons-outlined').textContent;
        button.querySelector('.mdc-button__label').textContent = '処理中...';
        button.querySelector('.material-icons-outlined').textContent = 'hourglass_empty';

        // 更新データ: ステータスを Assigned に変更
        const updateData = { caseStatus: 'Assigned' };

        // 1. searchCaseById で行番号を取得
        google.script.run
            .withSuccessHandler(searchResult => {
                if (searchResult.success && searchResult.rowIndex) {
                    const rowIndex = searchResult.rowIndex;
                    console.log(`Found row index ${rowIndex} for case ${caseId}. Updating status...`);
                    // 2. updateCaseData でステータスを更新
                    google.script.run
                        .withSuccessHandler(updateResult => {
                            if (updateResult.success) {
                                showSnackbar(`ケース ${caseId} を再アクティブ化しました。`, 'success');

                                // 検索結果画面の場合、ボタン表示を変更し、ダッシュボード更新を促す
                                if (card.closest('#searchResultContainer')) {
                                    button.querySelector('.mdc-button__label').textContent = 'アクティブ化済';
                                    button.querySelector('.material-icons-outlined').textContent = 'check_circle';
                                    // ボタンは無効のままにしておく
                                    setTimeout(() => {
                                        showSnackbar('ダッシュボードタブで更新ボタンを押して表示を確認してください。', 'info', 7000);
                                    }, 1000);
                                } else {
                                    // ダッシュボード画面の場合は、リストを再読み込みして更新を反映
                                    loadCasesData();
                                }
                            } else {
                                // 更新失敗
                                showSnackbar(updateResult.message || 'ステータスの更新に失敗しました。', 'error');
                                // ボタンを元に戻す
                                button.disabled = false;
                                button.querySelector('.mdc-button__label').textContent = originalLabel;
                                button.querySelector('.material-icons-outlined').textContent = originalIcon;
                            }
                        })
                        .withFailureHandler(error => {
                            // 更新API呼び出し失敗
                            showSnackbar(`ステータス更新APIエラー: ${error.message}`, 'error');
                            button.disabled = false;
                            button.querySelector('.mdc-button__label').textContent = originalLabel;
                            button.querySelector('.material-icons-outlined').textContent = originalIcon;
                        })
                        .updateCaseData(rowIndex, updateData); // dataAccess.gs の関数
                } else {
                    // ケース検索失敗
                    showSnackbar(searchResult.message || `ケース ${caseId} が見つかりませんでした。`, 'error');
                    button.disabled = false;
                    button.querySelector('.mdc-button__label').textContent = originalLabel;
                    button.querySelector('.material-icons-outlined').textContent = originalIcon;
                }
            })
            .withFailureHandler(error => {
                // 検索API呼び出し失敗
                showSnackbar(`ケース検索APIエラー: ${error.message}`, 'error');
                button.disabled = false;
                button.querySelector('.mdc-button__label').textContent = originalLabel;
                button.querySelector('.material-icons-outlined').textContent = originalIcon;
            })
            .searchCaseById(caseId); // dataAccess.gs の関数
    }

    /**
     * ケース編集用のモーダルダイアログを開き、指定されたケースIDのデータを読み込んで表示します。
     * @param {string} caseId - 編集対象のケースID。
     */
    function openCaseEditModal(caseId) {
        console.log(`openCaseEditModal called for caseId: ${caseId}`); // デバッグログ追加
        console.log("mdcDialog instance:", mdcDialog); // デバッグログ追加
        if (!mdcDialog) {
            console.error("MDC Dialog component is not initialized.");
            showSnackbar("編集ダイアログを開けません。", "error");
            return;
        }

        const modalContent = document.getElementById('caseDetailContent');
        const modalTitle = document.getElementById('case-dialog-title'); // IDを index.html に合わせる
        const saveButton = document.getElementById('saveCaseChangesBtn'); // 保存ボタンを取得

        if (!modalContent || !modalTitle || !saveButton) {
            console.error("Modal elements (content, title, or save button) not found.");
            return;
        }

        // モーダルタイトル設定
        modalTitle.textContent = `ケース編集: ${caseId}`;

        // モーダルコンテンツをリセットし、ローディング表示
        modalContent.innerHTML = `
    <div class="loading-container">
      <div class="mdc-linear-progress mdc-linear-progress--indeterminate">
        <div class="mdc-linear-progress__buffer"><div class="mdc-linear-progress__buffer-dots"></div><div class="mdc-linear-progress__buffer-bar"></div></div>
        <div class="mdc-linear-progress__bar mdc-linear-progress__primary-bar"><span class="mdc-linear-progress__bar-inner"></span></div>
        <div class="mdc-linear-progress__bar mdc-linear-progress__secondary-bar"><span class="mdc-linear-progress__bar-inner"></span></div>
      </div>
      <p>ケース ${caseId} の情報を読み込み中...</p>
    </div>`;
        const progressBar = modalContent.querySelector('.mdc-linear-progress');
        if (progressBar) {
            try { new mdc.linearProgress.MDCLinearProgress(progressBar); } catch (e) { console.warn("Failed to init progress bar for modal", e); }
        }

        // 保存ボタンを一旦非表示にし、古いリスナーを確実に削除するためにボタンを再生成
        saveButton.style.display = 'none';
        const newSaveButton = saveButton.cloneNode(true); // ディープコピー
        saveButton.parentNode.replaceChild(newSaveButton, saveButton);
        // (新しいボタンへの参照を更新する必要があるが、後続の処理で再度取得するためここでは不要)

        // モーダルを開く
        mdcDialog.open();

        // ケースデータをバックエンドから取得 (行番号も必要)
        google.script.run
            .withSuccessHandler(result => {
                if (result.success && result.data && result.rowIndex) {
                    // 成功したらフォームを表示
                    displayCaseEditForm(result.data, result.rowIndex, modalContent); // このファイル内で定義
                } else {
                    // データ取得失敗
                    modalContent.innerHTML = `
          <div class="error-message">
            <i class="material-icons-outlined">error</i>
            <p>${result.message || 'ケース情報の取得に失敗しました。'}</p>
          </div>`;
                    showSnackbar(result.message || 'ケース情報の取得に失敗しました。', 'error');
                }
            })
            .withFailureHandler(error => {
                // API呼び出し失敗
                const errorMessage = `ケース情報取得APIエラー: ${error.message}`;
                modalContent.innerHTML = `
        <div class="error-message">
          <i class="material-icons-outlined">cloud_off</i>
          <p>${errorMessage}</p>
        </div>`;
                showSnackbar(errorMessage, 'error');
            })
            .searchCaseById(caseId); // dataAccess.gs の関数
    }

    /**
     * ケース編集フォームのHTMLを生成し、モーダルダイアログのコンテンツエリアに表示します。
     * 動的に生成されたMDCコンポーネントやFlatpickrも初期化します。
     * @param {Object<string, string>} caseData - 表示するケースデータ。
     * @param {number} rowIndex - スプレッドシート上の行番号 (更新時に使用)。
     * @param {HTMLElement} container - フォームを表示するコンテナ要素 (#caseDetailContent)。
     */
    function displayCaseEditForm(caseData, rowIndex, container) {
        if (!caseData || !rowIndex || !container) {
            console.error("Invalid arguments for displayCaseEditForm", { caseData, rowIndex, container });
            container.innerHTML = `<div class="error-message"><p>フォーム表示中に内部エラーが発生しました。</p></div>`;
            return;
        }

        // フォーム定義がロードされているか確認 (script.html でロードされる)
        if (typeof formDefinitions === 'undefined' || Object.keys(formDefinitions).length === 0 ||
            !formDefinitions.caseStatus || !formDefinitions.amTransfer ||
            !formDefinitions.nonNCC || !formDefinitions.reopenReason) {
            console.error("Form definitions are missing or incomplete.", formDefinitions);
            container.innerHTML = `<div class="error-message"><p>フォームの選択肢定義の読み込みに失敗しました。</p></div>`;
            showSnackbar("フォーム定義が読み込まれていないため、編集フォームを表示できません。", "error");
            return;
        }

        const caseId = caseData['Case ID'];
        const currentStatus = caseData['Case Status'];
        const firstCloseDate = caseData['1st Close Date']; // 初回クローズ済みか判定用

        // --- フォームHTML生成 ---
        let formHtml = `
    <form id="caseEditForm" data-row-index="${rowIndex}" novalidate>
      <h3 class="form-section-title">基本情報 (編集不可)</h3>
      <div class="form-grid readonly-grid">
        <div class="info-item"><div class="info-label">Case ID</div><div class="info-value">${caseId}</div></div>
        <div class="info-item"><div class="info-label">開始日時</div><div class="info-value">${formatDate(caseData['Date'])} ${formatTime(caseData['Time'])}</div></div>
        <div class="info-item"><div class="info-label">担当者 (1st)</div><div class="info-value">${caseData['1st Assignee'] || '-'}</div></div>
        <div class="info-item"><div class="info-label">セグメント</div><div class="info-value">${caseData['Segment'] || '-'}</div></div>
        <div class="info-item"><div class="info-label">製品カテゴリ</div><div class="info-value">${caseData['Product Category'] || '-'}</div></div>
        <div class="info-item"><div class="info-label">問題カテゴリ</div><div class="info-value">${caseData['Issue Category'] || '-'}</div></div>
      </div>

      <hr class="form-divider">

      <h3 class="form-section-title">ステータス・任意項目 (編集可能)</h3>
      <div class="form-grid">
        <!-- Case Status (Select) - 必須 -->
        <div class="form-group required">
          ${createMdcSelectHtml('caseStatus', 'ケースステータス', formDefinitions.caseStatus, currentStatus, true)}
        </div>
        <!-- AM Transfer (Select) -->
        <div class="form-group">
          ${createMdcSelectHtml('amTransfer', 'AM Transfer', formDefinitions.amTransfer, caseData['AM Transfer'] || '', false, true)}
        </div>
        <!-- non NCC (Select) -->
        <div class="form-group">
          ${createMdcSelectHtml('nonNCC', 'non NCC', formDefinitions.nonNCC, caseData['non NCC'] || '', false, true)}
        </div>
        <!-- Sentiment Score (Number Input) -->
        <div class="form-group">
          ${createMdcTextFieldHtml('sentimentScore', 'Sentiment Score', caseData['Sentiment Score'] || '', false, '例: 85', 'number')}
        </div>
      </div>

      <div class="form-grid checkbox-grid">
        <!-- Bug (Checkbox) -->
        <div class="form-group">
          ${createMdcCheckboxHtml('bug', 'Bug', caseData['Bug'] == 1 || caseData['Bug'] === true)}
        </div>
        <!-- Need Info (Checkbox) -->
        <div class="form-group">
          ${createMdcCheckboxHtml('needInfo', 'Need Info', caseData['Need Info'] == 1 || caseData['Need Info'] === true)}
        </div>
        <!-- T&S Consulted (Checkbox) - 将来的な追加用 -->
        <!--
        <div class="form-group">
          ${createMdcCheckboxHtml('tsConsulted', 'T&S Consulted', caseData['T&S Consulted'] === 'Yes')}
        </div>
        -->
      </div>

      <hr class="form-divider">

      <h3 class="form-section-title">クローズ情報</h3>
      <div class="form-grid">
        <!-- 1st Close Date (Date Picker) -->
        <div class="form-group">
          ${createMdcTextFieldHtml('firstCloseDate', '初回クローズ日付', formatDate(firstCloseDate) || '', false, 'YYYY/MM/DD', 'date')}
        </div>
        <!-- 1st Close Time (Time Picker) -->
        <div class="form-group">
          ${createMdcTextFieldHtml('firstCloseTime', '初回クローズ時間', formatTime(caseData['1st Close Time']) || '', false, 'HH:MM:SS', 'time')}
        </div>
      </div>`;

        // 再オープン関連フィールド (初回クローズ済みの場合のみ表示)
        if (firstCloseDate) {
            formHtml += `
      <div class="form-grid reopen-section">
        <!-- Reopen Reason (Select) -->
        <div class="form-group">
          ${createMdcSelectHtml('reopenReason', '再オープン理由', formDefinitions.reopenReason, caseData['Reopen Reason'] || '', false, true)}
        </div>
        <!-- Reopen Close Date (Date Picker) -->
        <div class="form-group">
          ${createMdcTextFieldHtml('reopenCloseDate', '再クローズ日付', formatDate(caseData['Reopen Close Date']) || '', false, 'YYYY/MM/DD', 'date')}
        </div>
        <!-- Reopen Close Time (Time Picker) -->
        <div class="form-group">
          ${createMdcTextFieldHtml('reopenCloseTime', '再クローズ時間', formatTime(caseData['Reopen Close Time']) || '', false, 'HH:MM:SS', 'time')}
        </div>
      </div>`;
        }

        formHtml += `</form>`;
        // --- フォームHTML生成ここまで ---

        // コンテナにHTMLを設定
        container.innerHTML = formHtml;

        // --- 動的に生成されたMDCコンポーネントとFlatpickrを初期化 ---
        const formElement = container.querySelector('#caseEditForm');
        if (!formElement) return; // フォーム要素が見つからない場合は中断

        // Selects
        formElement.querySelectorAll('.mdc-select').forEach(el => {
            try {
                const mdcSel = new mdc.select.MDCSelect(el);
                if (el.id) mdcSelectComponents[el.id] = mdcSel; // キャッシュ
            } catch (e) { console.warn("Failed to init MDC Select in modal", e); }
        });

        // Checkboxes and Form Fields
        formElement.querySelectorAll('.mdc-checkbox').forEach(el => {
            try { new mdc.checkbox.MDCCheckbox(el); } catch (e) { console.warn("Failed to init MDC Checkbox in modal", e); }
        });
        formElement.querySelectorAll('.mdc-form-field').forEach(el => {
            try { new mdc.formField.MDCFormField(el); } catch (e) { console.warn("Failed to init MDC FormField in modal", e); }
        });

        // Text Fields
        formElement.querySelectorAll('.mdc-text-field').forEach(el => {
            try {
                const mdcTf = new mdc.textField.MDCTextField(el);
                if (el.id) mdcTextFieldComponents[el.id] = mdcTf; // キャッシュ (wrapper ID)
            } catch (e) { console.warn("Failed to init MDC TextField in modal", e); }
        });

        // 日付ピッカー初期化 (script.html で定義)
        initDatePicker(formElement.querySelector('#firstCloseDate'));
        if (firstCloseDate) { // 再オープンセクションが存在する場合のみ初期化
            initDatePicker(formElement.querySelector('#reopenCloseDate'));
        }

        // 時間ピッカー初期化 (script.html で定義)
        initTimePicker(formElement.querySelector('#firstCloseTime'));
        if (firstCloseDate) {
            initTimePicker(formElement.querySelector('#reopenCloseTime'));
        }
        // --- 初期化ここまで ---

        // 保存ボタンを表示し、イベントリスナーを再設定
        const saveButton = document.getElementById('saveCaseChangesBtn'); // 再度取得
        if (saveButton) {
            saveButton.style.display = 'inline-flex'; // 表示
            // イベントリスナーを設定
            saveButton.addEventListener('click', () => {
                const formData = collectEditFormData(formElement); // このファイル内で定義
                if (formData) {
                    // バリデーション成功
                    updateCaseData(rowIndex, formData); // このファイル内で定義
                } else {
                    // バリデーション失敗
                    console.log("Form validation failed.");
                    // Snackbar は collectEditFormData 内で表示される
                }
            });
            // リップル初期化
            try { new mdc.ripple.MDCRipple(saveButton); } catch (e) { console.warn("Failed to init ripple for save button", e); }
        }
    }

    /**
     * ケース編集フォームから入力されたデータを収集し、オブジェクトとして返します。
     * 簡単なバリデーション（必須項目、日付/時間形式、Sentiment Score形式）も行います。
     * @param {HTMLFormElement} formElement - データ収集対象のフォーム要素。
     * @returns {Object<string, any>|null} 収集したデータオブジェクト。バリデーションエラーがあった場合は null。
     */
    function collectEditFormData(formElement) {
        if (!formElement) return null;
        const formData = {};
        let isValid = true; // バリデーションフラグ

        // Selects
        formElement.querySelectorAll('.mdc-select').forEach(selectEl => {
            // attachTo で既存のインスタンスを取得 (なければ null)
            const selectComponent = mdcSelectComponents[selectEl.id] || mdc.select.MDCSelect.attachTo(selectEl);
            const name = selectEl.id; // select 要素の ID をキーとする
            if (selectComponent) {
                formData[name] = selectComponent.value;
                // 必須チェック
                if (selectEl.closest('.form-group.required') && !selectComponent.value) {
                    console.warn(`Validation failed: ${name} is required.`);
                    showSnackbar(`${selectEl.querySelector('.mdc-floating-label')?.textContent || name} は必須です。`, 'warn');
                    // エラー表示 (MDC Select の標準エラー表示を使う方が良いかもしれない)
                    selectComponent.valid = false;
                    isValid = false;
                } else if (selectComponent) {
                    selectComponent.valid = true; // エラー解除
                }
            } else {
                console.warn(`MDCSelect component not found for ${name}`);
            }
        });

        // Checkboxes
        formElement.querySelectorAll('.mdc-checkbox input[type="checkbox"]').forEach(checkboxEl => {
            const name = checkboxEl.id;
            formData[name] = checkboxEl.checked; // boolean 値
        });

        // Text Fields (Date/Time/Sentiment Score)
        formElement.querySelectorAll('.mdc-text-field input').forEach(inputEl => {
            const name = inputEl.id;
            const value = inputEl.value.trim();
            formData[name] = value; // trim した値を格納

            const mdcTfWrapper = mdcTextFieldComponents[`${name}-wrapper`]; // wrapper ID で取得

            // バリデーション
            let isValidFormat = true;
            let expectedFormat = '';
            let validationMessage = '';

            if (value) { // 値が存在する場合のみバリデーション
                if (name.includes('Date')) {
                    expectedFormat = 'YYYY/MM/DD';
                    isValidFormat = /^\d{4}\/\d{2}\/\d{2}$/.test(value);
                    validationMessage = `${expectedFormat} 形式で入力してください。`;
                } else if (name.includes('Time')) {
                    expectedFormat = 'HH:MM:SS';
                    isValidFormat = /^\d{2}:\d{2}:\d{2}$/.test(value);
                    validationMessage = `${expectedFormat} 形式で入力してください。`;
                } else if (name === 'sentimentScore') {
                    const score = parseFloat(value);
                    // 数値であること、および範囲 (例: 0-100) をチェック
                    // 範囲は要件に応じて調整
                    isValidFormat = !isNaN(score) && score >= 0 && score <= 100;
                    validationMessage = '0から100の数値を入力してください。';
                }
            }

            // バリデーション結果を反映
            if (!isValidFormat) {
                const label = inputEl.closest('.mdc-text-field')?.querySelector('.mdc-floating-label')?.textContent || name;
                showSnackbar(`${label}: ${validationMessage}`, 'warn');
                if (mdcTfWrapper) mdcTfWrapper.valid = false; // エラー表示
                isValid = false;
            } else {
                if (mdcTfWrapper) mdcTfWrapper.valid = true; // エラー解除
            }
        });

        console.log("Collected form data:", formData, "Validation result:", isValid);
        return isValid ? formData : null;
    }

    /**
     * ケースデータをバックエンド (dataAccess.gs の updateCaseData) に送信して更新します。
     * @param {number} rowIndex - 更新対象のスプレッドシート上の行番号。
     * @param {Object<string, any>} formData - 更新するデータを含むオブジェクト。
     */
    function updateCaseData(rowIndex, formData) {
        if (!rowIndex || !formData) {
            showSnackbar("更新データの準備中にエラーが発生しました。", "error");
            return;
        }

        console.log(`Updating case data for row ${rowIndex}:`, formData);
        // 保存ボタンを無効化し、ローディング表示
        const saveButton = document.getElementById('saveCaseChangesBtn');
        let originalLabel = '保存'; // デフォルト
        let originalIcon = 'save'; // デフォルト
        if (saveButton) {
            saveButton.disabled = true;
            originalLabel = saveButton.querySelector('.mdc-button__label').textContent;
            originalIcon = saveButton.querySelector('.material-icons-outlined').textContent;
            saveButton.querySelector('.mdc-button__label').textContent = '保存中...';
            saveButton.querySelector('.material-icons-outlined').textContent = 'hourglass_empty';
        }

        // google.script.run でバックエンド関数を呼び出し
        google.script.run
            .withSuccessHandler(result => {
                // 保存ボタンを元に戻す
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.querySelector('.mdc-button__label').textContent = originalLabel;
                    saveButton.querySelector('.material-icons-outlined').textContent = originalIcon;
                }

                if (result.success) {
                    showSnackbar(result.message || 'ケースが正常に更新されました。', 'success');
                    if (mdcDialog) mdcDialog.close(); // モーダルを閉じる
                    // ダッシュボードの表示を更新
                    loadCasesData();
                } else {
                    // 更新失敗 (バックエンドからのエラー)
                    showSnackbar(result.message || 'ケースの更新に失敗しました。', 'error');
                }
            })
            .withFailureHandler(error => {
                // API呼び出し失敗
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.querySelector('.mdc-button__label').textContent = originalLabel;
                    saveButton.querySelector('.material-icons-outlined').textContent = originalIcon;
                }
                showSnackbar(`ケース更新APIエラー: ${error.message}`, 'error');
            })
            .updateCaseData(rowIndex, formData); // dataAccess.gs の関数
    }

    /**
     * ケースステータス文字列に対応するCSSクラス名を返します。
     * ケースカードのスタイル設定に使用されます。
     * @param {string} status - ケースステータス文字列。
     * @returns {string} 対応するCSSクラス名。
     */
    function getStatusClass(status) {
        switch (status) {
            case 'Assigned':
                return 'status-assigned';
            case 'Solution Offered':
                return 'status-solution-offered';
            case 'Finished':
                return 'status-finished';
            default:
                console.warn(`Unknown status encountered: ${status}`);
                return 'status-unknown'; // 不明なステータス用のクラス
        }
    }
</script>